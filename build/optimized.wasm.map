{"version":3,"sources":["~lib/rt/common.ts","~lib/shared/typeinfo.ts","~lib/rt/pure.ts","~lib/rt/tlsf.ts","~lib/gc.ts","assembly/index.ts"],"names":[],"mappings":"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","sourceRoot":"./optimized.wasm","sourcesContent":["// Alignment guarantees\r\n\r\n// @ts-ignore: decorator\r\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\r\n// @ts-ignore: decorator\r\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline export const AL_MASK: usize = AL_SIZE - 1;\r\n\r\n// Extra debugging\r\n\r\n// @ts-ignore: decorator\r\n@inline export const DEBUG = true;\r\n\r\n// ╒════════════════ Common block layout (32-bit) ═════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │                           MM info                             │ -16\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                           GC info                             │ -12\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                          runtime id                           │ -8\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                         runtime size                          │ -4\r\n// ╞═══════════════════════════════════════════════════════════════╡\r\n// │                              ...                              │ ref\r\n@unmanaged export class BLOCK {\r\n  /** Memory manager info. */\r\n  mmInfo: usize; // WASM64 needs adaption\r\n  /** Garbage collector info. */\r\n  gcInfo: u32;\r\n  /** Runtime class id. */\r\n  rtId: u32;\r\n  /** Runtime object size. */\r\n  rtSize: u32;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_OVERHEAD: usize = (offsetof<BLOCK>() + AL_MASK) & ~AL_MASK;\r\n\r\n// @ts-ignore: decorator\r\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\r\n","// This file is shared with the compiler and must remain portable\r\n\r\n// ╒═══════════════════ Typeinfo interpretation ═══════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤ ◄─ __rtti_base\r\n// │                             count                             │\r\n// ╞═══════════════════════════════════════════════════════════════╡ ┐\r\n// │                      Typeinfo#flags [id=0]                    │ id < count\r\n// ├ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ┤\r\n// │                      Typeinfo#base  [id=0]                    │\r\n// ├───────────────────────────────────────────────────────────────┤\r\n// │                              ...                              │\r\n\r\n/** Runtime type information data structure. */\r\n@unmanaged\r\nexport class Typeinfo {\r\n  /** Flags describing the shape of this class type. */\r\n  flags: TypeinfoFlags;\r\n  /** Base class id or `0` if none. */\r\n  base: u32;\r\n}\r\n\r\n/** Runtime type information flags. */\r\nexport const enum TypeinfoFlags {\r\n  /** No specific flags. */\r\n  NONE = 0,\r\n  /** Type is an `ArrayBufferView`. */\r\n  ARRAYBUFFERVIEW = 1 << 0,\r\n  /** Type is an `Array`. */\r\n  ARRAY = 1 << 1,\r\n  /** Type is a `StaticArray`. */\r\n  STATICARRAY = 1 << 2,\r\n  /** Type is a `Set`. */\r\n  SET = 1 << 3,\r\n  /** Type is a `Map`. */\r\n  MAP = 1 << 4,\r\n  /** Type is inherently acyclic. */\r\n  ACYCLIC = 1 << 5,\r\n  /** Value alignment of 1 byte. */\r\n  VALUE_ALIGN_0 = 1 << 6,\r\n  /** Value alignment of 2 bytes. */\r\n  VALUE_ALIGN_1 = 1 << 7,\r\n  /** Value alignment of 4 bytes. */\r\n  VALUE_ALIGN_2 = 1 << 8,\r\n  /** Value alignment of 8 bytes. */\r\n  VALUE_ALIGN_3 = 1 << 9,\r\n  /** Value alignment of 16 bytes. */\r\n  VALUE_ALIGN_4 = 1 << 10,\r\n  /** Value is a signed type. */\r\n  VALUE_SIGNED = 1 << 11,\r\n  /** Value is a float type. */\r\n  VALUE_FLOAT = 1 << 12,\r\n  /** Value type is nullable. */\r\n  VALUE_NULLABLE = 1 << 13,\r\n  /** Value type is managed. */\r\n  VALUE_MANAGED = 1 << 14,\r\n  /** Key alignment of 1 byte. */\r\n  KEY_ALIGN_0 = 1 << 15,\r\n  /** Key alignment of 2 bytes. */\r\n  KEY_ALIGN_1 = 1 << 16,\r\n  /** Key alignment of 4 bytes. */\r\n  KEY_ALIGN_2 = 1 << 17,\r\n  /** Key alignment of 8 bytes. */\r\n  KEY_ALIGN_3 = 1 << 18,\r\n  /** Key alignment of 16 bytes. */\r\n  KEY_ALIGN_4 = 1 << 19,\r\n  /** Key is a signed type. */\r\n  KEY_SIGNED = 1 << 20,\r\n  /** Key is a float type. */\r\n  KEY_FLOAT = 1 << 21,\r\n  /** Key type is nullable. */\r\n  KEY_NULLABLE = 1 << 22,\r\n  /** Key type is managed. */\r\n  KEY_MANAGED = 1 << 23\r\n}\r\n","import { DEBUG, BLOCK_OVERHEAD } from \"rt/common\";\r\nimport { Block, freeBlock, ROOT } from \"rt/tlsf\";\r\nimport { TypeinfoFlags } from \"shared/typeinfo\";\r\nimport { onincrement, ondecrement, onfree, onalloc } from \"./rtrace\";\r\n\r\n/////////////////////////// A Pure Reference Counting Garbage Collector ///////////////////////////\r\n// see:     https://researcher.watson.ibm.com/researcher/files/us-bacon/Bacon03Pure.pdf\r\n\r\n// ╒══════════════════════ GC Info structure ══════════════════════╕\r\n// │  3                   2                   1                    │\r\n// │1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0│\r\n// ├─┼─┴─┴─┼─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤\r\n// │B│color│                     refCount                          │\r\n// └─┴─────┴───────────────────────────────────────────────────────┘\r\n// B: buffered\r\n\r\n// @ts-ignore: decorator\r\n@inline const BUFFERED_MASK: u32 = 1 << ((sizeof<u32>() * 8) - 1);\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BITS = 3;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_SHIFT: u32 = ctz(BUFFERED_MASK) - COLOR_BITS;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_MASK: u32 = ((1 << COLOR_BITS) - 1) << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline export const REFCOUNT_MASK: u32 = (1 << COLOR_SHIFT) - 1;\r\n\r\n// ╒════════╤═══════════════════ Colors ═══════════════════════════╕\r\n// │ Color  │ Meaning                                              │\r\n// ├────────┼──────────────────────────────────────────────────────┤\r\n// │ BLACK  │ In use or free                                       │\r\n// │ GRAY   │ Possible member of cycle                             │\r\n// │ WHITE  │ Member of garbage cycle                              │\r\n// │ PURPLE │ Possible root of cycle                               │\r\n// │ RED    │ Candidate cycle undergoing Σ-computation *concurrent │\r\n// │ ORANGE │ Candidate cycle awaiting epoch boundary  *concurrent │\r\n// └────────┴──────────────────────────────────────────────────────┘\r\n// Acyclic detection has been decoupled, hence no GREEN.\r\n\r\n// @ts-ignore: decorator\r\n@inline const COLOR_BLACK: u32 = 0 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_GRAY: u32 = 1 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_WHITE: u32 = 2 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n@inline const COLOR_PURPLE: u32 = 3 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_RED: u32 = 4 << COLOR_SHIFT;\r\n// @ts-ignore: decorator\r\n// @inline const COLOR_ORANGE: u32 = 5 << COLOR_SHIFT;\r\n\r\n// @ts-ignore: decorator\r\n@inline const VISIT_DECREMENT = 1; // guard 0\r\n// @ts-ignore: decorator\r\n@inline const VISIT_MARKGRAY = 2;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCAN = 3;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_SCANBLACK = 4;\r\n// @ts-ignore: decorator\r\n@inline const VISIT_COLLECTWHITE = 5;\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe @lazy\r\nfunction __visit(ref: usize, cookie: i32): void {\r\n  if (ref < __heap_base) return;\r\n  if (isDefined(__GC_ALL_ACYCLIC)) {\r\n    if (DEBUG) assert(cookie == VISIT_DECREMENT);\r\n    decrement(changetype<Block>(ref - BLOCK_OVERHEAD));\r\n  } else {\r\n    let s = changetype<Block>(ref - BLOCK_OVERHEAD);\r\n    switch (cookie) {\r\n      case VISIT_DECREMENT: {\r\n        decrement(s);\r\n        break;\r\n      }\r\n      case VISIT_MARKGRAY: {\r\n        if (DEBUG) assert((s.gcInfo & REFCOUNT_MASK) > 0);\r\n        s.gcInfo = s.gcInfo - 1;\r\n        markGray(s);\r\n        break;\r\n      }\r\n      case VISIT_SCAN: {\r\n        scan(s);\r\n        break;\r\n      }\r\n      case VISIT_SCANBLACK: {\r\n        let info = s.gcInfo;\r\n        assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n        s.gcInfo = info + 1;\r\n        if ((info & COLOR_MASK) != COLOR_BLACK) {\r\n          scanBlack(s);\r\n        }\r\n        break;\r\n      }\r\n      case VISIT_COLLECTWHITE: {\r\n        collectWhite(s);\r\n        break;\r\n      }\r\n      default: if (DEBUG) assert(false);\r\n    }\r\n  }\r\n}\r\n\r\n/** Increments the reference count of the specified block by one.*/\r\nfunction increment(s: Block): void {\r\n  var info = s.gcInfo;\r\n  assert((info & ~REFCOUNT_MASK) == ((info + 1) & ~REFCOUNT_MASK)); // overflow\r\n  s.gcInfo = info + 1;\r\n  if (isDefined(ASC_RTRACE)) onincrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n}\r\n\r\n/** Decrements the reference count of the specified block by one, possibly freeing it. */\r\n// @ts-ignore: decorator\r\n@lazy\r\nfunction decrement(s: Block): void {\r\n  var info = s.gcInfo;\r\n  var rc = info & REFCOUNT_MASK;\r\n  if (isDefined(ASC_RTRACE)) ondecrement(s);\r\n  if (DEBUG) assert(!(s.mmInfo & 1)); // used\r\n  if (rc == 1) {\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_DECREMENT);\r\n    if (isDefined(__GC_ALL_ACYCLIC)) {\r\n      if (DEBUG) assert(!(info & BUFFERED_MASK));\r\n      freeBlock(ROOT, s);\r\n    } else {\r\n      if (!(info & BUFFERED_MASK)) {\r\n        freeBlock(ROOT, s);\r\n      } else {\r\n        s.gcInfo = BUFFERED_MASK | COLOR_BLACK | 0;\r\n      }\r\n    }\r\n  } else {\r\n    if (DEBUG) assert(rc > 0);\r\n    if (isDefined(__GC_ALL_ACYCLIC)) {\r\n      s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n    } else {\r\n      if (!(__typeinfo(s.rtId) & TypeinfoFlags.ACYCLIC)) {\r\n        s.gcInfo = BUFFERED_MASK | COLOR_PURPLE | (rc - 1);\r\n        if (!(info & BUFFERED_MASK)) {\r\n          appendRoot(s);\r\n        }\r\n      } else {\r\n        s.gcInfo = (info & ~REFCOUNT_MASK) | (rc - 1);\r\n      }\r\n    }\r\n  }\r\n}\r\n\r\n/** Buffer of possible roots. */\r\n// @ts-ignore: decorator\r\n@lazy var ROOTS: usize;\r\n/** Current absolute offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var CUR: usize = 0;\r\n/** Current absolute end offset into the `ROOTS` buffer. */\r\n// @ts-ignore: decorator\r\n@lazy var END: usize = 0;\r\n\r\n/** Appends a block to possible roots. */\r\nfunction appendRoot(s: Block): void {\r\n  var cur = CUR;\r\n  if (cur >= END) {\r\n    growRoots(); // TBD: either that or pick a default and force collection on overflow\r\n    cur = CUR;\r\n  }\r\n  store<Block>(cur, s);\r\n  CUR = cur + sizeof<usize>();\r\n}\r\n\r\n/** Grows the roots buffer if it ran full. */\r\nfunction growRoots(): void {\r\n  var oldRoots = ROOTS;\r\n  var oldSize = CUR - oldRoots;\r\n  var newSize = max(oldSize * 2, 64 << alignof<usize>());\r\n  var newRoots = __alloc(newSize, 0);\r\n  if (isDefined(ASC_RTRACE)) onfree(changetype<Block>(newRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n  memory.copy(newRoots, oldRoots, oldSize);\r\n  if (oldRoots) {\r\n    if (isDefined(ASC_RTRACE)) onalloc(changetype<Block>(oldRoots - BLOCK_OVERHEAD)); // neglect unmanaged\r\n    __free(oldRoots);\r\n  }\r\n  ROOTS = newRoots;\r\n  CUR = newRoots + oldSize;\r\n  END = newRoots + newSize;\r\n}\r\n\r\n/** Collects cyclic garbage. */\r\n// @ts-ignore: decorator\r\n@global @unsafe @lazy\r\nexport function __collect(): void {\r\n  if (isDefined(__GC_ALL_ACYCLIC)) return;\r\n\r\n  // markRoots\r\n  var roots = ROOTS;\r\n  var cur = roots;\r\n  for (let pos = cur, end = CUR; pos < end; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    let info = s.gcInfo;\r\n    if ((info & COLOR_MASK) == COLOR_PURPLE && (info & REFCOUNT_MASK) > 0) {\r\n      markGray(s);\r\n      store<Block>(cur, s);\r\n      cur += sizeof<usize>();\r\n    } else {\r\n      if ((info & COLOR_MASK) == COLOR_BLACK && !(info & REFCOUNT_MASK)) {\r\n        freeBlock(ROOT, s);\r\n      } else {\r\n        s.gcInfo = info & ~BUFFERED_MASK;\r\n      }\r\n    }\r\n  }\r\n  CUR = cur;\r\n\r\n  // scanRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    scan(load<Block>(pos));\r\n  }\r\n\r\n  // collectRoots\r\n  for (let pos = roots; pos < cur; pos += sizeof<usize>()) {\r\n    let s = load<Block>(pos);\r\n    s.gcInfo = s.gcInfo & ~BUFFERED_MASK;\r\n    collectWhite(s);\r\n  }\r\n  CUR = roots;\r\n}\r\n\r\n/** Marks a block as gray (possible member of cycle) during the collection phase. */\r\nfunction markGray(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) != COLOR_GRAY) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_GRAY;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_MARKGRAY);\r\n  }\r\n}\r\n\r\n/** Scans a block during the collection phase, determining whether it is garbage or not. */\r\nfunction scan(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_GRAY) {\r\n    if ((info & REFCOUNT_MASK) > 0) {\r\n      scanBlack(s);\r\n    } else {\r\n      s.gcInfo = (info & ~COLOR_MASK) | COLOR_WHITE;\r\n      __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCAN);\r\n    }\r\n  }\r\n}\r\n\r\n/** Marks a block as black (in use) if it was found to be reachable during the collection phase. */\r\nfunction scanBlack(s: Block): void {\r\n  s.gcInfo = (s.gcInfo & ~COLOR_MASK) | COLOR_BLACK;\r\n  __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_SCANBLACK);\r\n}\r\n\r\n/** Collects all white (member of a garbage cycle) nodes when completing the collection phase.  */\r\nfunction collectWhite(s: Block): void {\r\n  var info = s.gcInfo;\r\n  if ((info & COLOR_MASK) == COLOR_WHITE && !(info & BUFFERED_MASK)) {\r\n    s.gcInfo = (info & ~COLOR_MASK) | COLOR_BLACK;\r\n    __visit_members(changetype<usize>(s) + BLOCK_OVERHEAD, VISIT_COLLECTWHITE);\r\n    freeBlock(ROOT, s);\r\n  }\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __retain(ptr: usize): usize {\r\n  if (ptr > __heap_base) increment(changetype<Block>(ptr - BLOCK_OVERHEAD));\r\n  return ptr;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __release(ptr: usize): void {\r\n  if (ptr > __heap_base) decrement(changetype<Block>(ptr - BLOCK_OVERHEAD));\r\n}\r\n","import { AL_BITS, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"rt/common\";\r\nimport { onfree, onalloc, onrealloc } from \"./rtrace\";\r\nimport { REFCOUNT_MASK } from \"./pure\";\r\n\r\n/////////////////////// The TLSF (Two-Level Segregate Fit) memory allocator ///////////////////////\r\n//                             see: http://www.gii.upv.es/tlsf/\r\n\r\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\r\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\r\n\r\n// ╒══════════════ Block size interpretation (32-bit) ═════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┴─┴─┴─╫─┴─┴─┴─┤\r\n// │ |                    FL                       │ SB = SL + AL  │ ◄─ usize\r\n// └───────────────────────────────────────────────┴───────╨───────┘\r\n// FL: first level, SL: second level, AL: alignment, SB: small block\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_BITS: u32 = 4;\r\n// @ts-ignore: decorator\r\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\r\n// @ts-ignore: decorator\r\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\r\n\r\n// @ts-ignore: decorator\r\n@inline const FL_BITS: u32 = 31 - SB_BITS;\r\n\r\n// [00]: < 256B (SB)  [12]: < 1M\r\n// [01]: < 512B       [13]: < 2M\r\n// [02]: < 1K         [14]: < 4M\r\n// [03]: < 2K         [15]: < 8M\r\n// [04]: < 4K         [16]: < 16M\r\n// [05]: < 8K         [17]: < 32M\r\n// [06]: < 16K        [18]: < 64M\r\n// [07]: < 32K        [19]: < 128M\r\n// [08]: < 64K        [20]: < 256M\r\n// [09]: < 128K       [21]: < 512M\r\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\r\n// [11]: < 512K\r\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\r\n\r\n// Tags stored in otherwise unused alignment bits\r\n\r\n// @ts-ignore: decorator\r\n@inline const FREE: usize = 1 << 0;\r\n// @ts-ignore: decorator\r\n@inline const LEFTFREE: usize = 1 << 1;\r\n// @ts-ignore: decorator\r\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\r\n\r\n// ╒════════════════════ Block layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┼─┼─┼─┤ overhead   ┐\r\n// │                          size                           │0│L│F│ ◄─┐ info\r\n// ├─────────────────────────────────────────────────────────┴─┴─┴─┤   │\r\n// │                                                               │   │\r\n// │               ... additional runtime overhead ...             │   │\r\n// │                                                               │   │\r\n// ╞═══════════════════════════════════════════════════════════════╡   │      ┐ ┘\r\n// │                        if free: ◄ prev                        │ ◄─┤ usize\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: next ►                        │ ◄─┤\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                             ...                               │   │    = 0\r\n// ├───────────────────────────────────────────────────────────────┤   │\r\n// │                        if free: back ▲                        │ ◄─┘\r\n// └───────────────────────────────────────────────────────────────┘ payload  ┘ >= MIN SIZE\r\n// F: FREE, L: LEFTFREE\r\n@unmanaged export class Block extends BLOCK {\r\n\r\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\r\n  prev: Block | null;\r\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\r\n  next: Block | null;\r\n\r\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\r\n}\r\n\r\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\r\n// `next` and `back` if free.\r\n\r\n// @ts-ignore: decorator\r\n@inline const BLOCK_MINSIZE: usize = (3 * sizeof<usize>() + AL_MASK) & ~AL_MASK; // prev + next + back\r\n// @ts-ignore: decorator\r\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\r\n\r\n/** Gets the left block of a block. Only valid if the left block is free. */\r\n// @ts-ignore: decorator\r\n@inline function GETFREELEFT(block: Block): Block {\r\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\r\n}\r\n\r\n/** Gets the right block of of a block by advancing to the right by its size. */\r\n// @ts-ignore: decorator\r\n@inline function GETRIGHT(block: Block): Block {\r\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\r\n}\r\n\r\n// ╒═════════════════════ Root layout (32-bit) ════════════════════╕\r\n//    3                   2                   1\r\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\r\n// ├─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┴─┤          ┐\r\n// │        0        |           flMap                            S│ ◄────┐\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                           slMap[0] S                          │ ◄─┐  │\r\n// ├───────────────────────────────────────────────────────────────┤   │  │\r\n// │                           slMap[1]                            │ ◄─┤  │\r\n// ├───────────────────────────────────────────────────────────────┤  u32 │\r\n// │                           slMap[22]                           │ ◄─┘  │\r\n// ╞═══════════════════════════════════════════════════════════════╡    usize\r\n// │                            head[0]                            │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                              ...                              │ ◄────┤\r\n// ├───────────────────────────────────────────────────────────────┤      │\r\n// │                           head[367]                           │ ◄────┤\r\n// ╞═══════════════════════════════════════════════════════════════╡      │\r\n// │                             tail                              │ ◄────┘\r\n// └───────────────────────────────────────────────────────────────┘   SIZE   ┘\r\n// S: Small blocks map\r\n@unmanaged class Root {\r\n  /** First level bitmap. */\r\n  flMap: usize;\r\n}\r\n\r\n// Root constants. Where stuff is stored inside of the root structure.\r\n\r\n// @ts-ignore: decorator\r\n@inline const SL_START: usize = sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\r\n// @ts-ignore: decorator\r\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\r\n// @ts-ignore: decorator\r\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\r\n// @ts-ignore: decorator\r\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\r\n\r\n// @ts-ignore: decorator\r\n@lazy export var ROOT: Root;\r\n\r\n/** Gets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function GETSL(root: Root, fl: usize): u32 {\r\n  return load<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Sets the second level map of the specified first level. */\r\n// @ts-ignore: decorator\r\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\r\n  store<u32>(\r\n    changetype<usize>(root) + (fl << alignof<u32>()),\r\n    slMap,\r\n    SL_START\r\n  );\r\n}\r\n\r\n/** Gets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\r\n  return load<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Sets the head of the free list for the specified combination of first and second level. */\r\n// @ts-ignore: decorator\r\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\r\n  store<Block>(\r\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\r\n    head,\r\n    HL_START\r\n  );\r\n}\r\n\r\n/** Gets the tail block.. */\r\n// @ts-ignore: decorator\r\n@inline function GETTAIL(root: Root): Block {\r\n  return load<Block>(\r\n    changetype<usize>(root),\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Sets the tail block. */\r\n// @ts-ignore: decorator\r\n@inline function SETTAIL(root: Root, tail: Block): void {\r\n  store<Block>(\r\n    changetype<usize>(root),\r\n    tail,\r\n    HL_END\r\n  );\r\n}\r\n\r\n/** Inserts a previously used block back into the free list. */\r\nfunction insertBlock(root: Root, block: Block): void {\r\n  if (DEBUG) assert(block); // cannot be null\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n\r\n  // merge with right block if also free\r\n  if (rightInfo & FREE) {\r\n    let newSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, right);\r\n      block.mmInfo = blockInfo = (blockInfo & TAGS_MASK) | newSize;\r\n      right = GETRIGHT(block);\r\n      rightInfo = right.mmInfo;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  // merge with left block if also free\r\n  if (blockInfo & LEFTFREE) {\r\n    let left = GETFREELEFT(block);\r\n    let leftInfo = left.mmInfo;\r\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\r\n    let newSize = (leftInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK);\r\n    if (newSize < BLOCK_MAXSIZE) {\r\n      removeBlock(root, left);\r\n      left.mmInfo = blockInfo = (leftInfo & TAGS_MASK) | newSize;\r\n      block = left;\r\n      // 'back' is set below\r\n    }\r\n  }\r\n\r\n  right.mmInfo = rightInfo | LEFTFREE;\r\n  // right is no longer used now, hence rightInfo is not synced\r\n\r\n  // we now know the size of the block\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be a valid size\r\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\r\n\r\n  // set 'back' to itself at the end of block\r\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // perform insertion\r\n  var head = GETHEAD(root, fl, sl);\r\n  block.prev = null;\r\n  block.next = head;\r\n  if (head) head.prev = block;\r\n  SETHEAD(root, fl, sl, block);\r\n\r\n  // update first and second level maps\r\n  root.flMap |= (1 << fl);\r\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\r\n}\r\n\r\n/** Removes a free block from internal lists. */\r\nfunction removeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(blockInfo & FREE); // must be free\r\n  var size = blockInfo & ~TAGS_MASK;\r\n  if (DEBUG) assert(size >= BLOCK_MINSIZE && size < BLOCK_MAXSIZE); // must be valid\r\n\r\n  // mapping_insert\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    fl = inv - clz<usize>(size);\r\n    sl = <u32>((size >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // link previous and next free block\r\n  var prev = block.prev;\r\n  var next = block.next;\r\n  if (prev) prev.next = next;\r\n  if (next) next.prev = prev;\r\n\r\n  // update head if we are removing it\r\n  if (block == GETHEAD(root, fl, sl)) {\r\n    SETHEAD(root, fl, sl, next);\r\n\r\n    // clear second level map if head is empty now\r\n    if (!next) {\r\n      let slMap = GETSL(root, fl);\r\n      SETSL(root, fl, slMap &= ~(1 << sl));\r\n\r\n      // clear first level map if second level is empty now\r\n      if (!slMap) root.flMap &= ~(1 << fl);\r\n    }\r\n  }\r\n  // note: does not alter left/back because it is likely that splitting\r\n  // is performed afterwards, invalidating those changes. so, the caller\r\n  // must perform those updates.\r\n}\r\n\r\n/** Searches for a free block of at least the specified size. */\r\nfunction searchBlock(root: Root, size: usize): Block | null {\r\n  // size was already asserted by caller\r\n\r\n  // mapping_search\r\n  var fl: usize, sl: u32;\r\n  if (size < SB_SIZE) {\r\n    fl = 0;\r\n    sl = <u32>(size >> AL_BITS);\r\n  } else {\r\n    const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\r\n    const inv: usize = sizeof<usize>() * 8 - 1;\r\n    const invRound = inv - SL_BITS;\r\n    let requestSize = size < halfMaxSize\r\n      ? size + (1 << (invRound - clz<usize>(size))) - 1\r\n      : size;\r\n    fl = inv - clz<usize>(requestSize);\r\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\r\n    fl -= SB_BITS - 1;\r\n  }\r\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\r\n\r\n  // search second level\r\n  var slMap = GETSL(root, fl) & (~0 << sl);\r\n  var head: Block | null = null;\r\n  if (!slMap) {\r\n    // search next larger first level\r\n    let flMap = root.flMap & (~0 << (fl + 1));\r\n    if (!flMap) {\r\n      head = null;\r\n    } else {\r\n      fl = ctz<usize>(flMap);\r\n      slMap = GETSL(root, fl);\r\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\r\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n    }\r\n  } else {\r\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\r\n  }\r\n  return head;\r\n}\r\n\r\n/** Prepares the specified block before (re-)use, possibly splitting it. */\r\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\r\n  // size was already asserted by caller\r\n\r\n  var blockInfo = block.mmInfo;\r\n  if (DEBUG) assert(!(size & AL_MASK)); // size must be aligned so the new block is\r\n\r\n  // split if the block can hold another MINSIZE block incl. overhead\r\n  var remaining = (blockInfo & ~TAGS_MASK) - size;\r\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\r\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\r\n\r\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\r\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\r\n    insertBlock(root, spare); // also sets 'back'\r\n\r\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\r\n  } else {\r\n    block.mmInfo = blockInfo & ~FREE;\r\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\r\n  }\r\n}\r\n\r\n/** Adds more memory to the pool. */\r\nfunction addMemory(root: Root, start: usize, end: usize): bool {\r\n  if (DEBUG) {\r\n    assert(\r\n      start <= end &&       // must be valid\r\n      !(start & AL_MASK) && // must be aligned\r\n      !(end & AL_MASK)      // must be aligned\r\n    );\r\n  }\r\n\r\n  var tail = GETTAIL(root);\r\n  var tailInfo: usize = 0;\r\n  if (tail) { // more memory\r\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\r\n\r\n    // merge with current tail if adjacent\r\n    if (start - BLOCK_OVERHEAD == changetype<usize>(tail)) {\r\n      start -= BLOCK_OVERHEAD;\r\n      tailInfo = tail.mmInfo;\r\n    } else {\r\n      // We don't do this, but a user might `memory.grow` manually\r\n      // leading to non-adjacent pages managed by TLSF.\r\n    }\r\n\r\n  } else if (DEBUG) { // first memory\r\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\r\n  }\r\n\r\n  // check if size is large enough for a free block and the tail block\r\n  var size = end - start;\r\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\r\n    return false;\r\n  }\r\n\r\n  // left size is total minus its own and the zero-length tail's header\r\n  var leftSize = size - (BLOCK_OVERHEAD << 1);\r\n  var left = changetype<Block>(start);\r\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\r\n  left.prev = null;\r\n  left.next = null;\r\n\r\n  // tail is a zero-length used block\r\n  tail = changetype<Block>(start + size - BLOCK_OVERHEAD);\r\n  tail.mmInfo = 0 | LEFTFREE;\r\n  SETTAIL(root, tail);\r\n\r\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\r\n\r\n  return true;\r\n}\r\n\r\n/** Grows memory to fit at least another block of the specified size. */\r\nfunction growMemory(root: Root, size: usize): void {\r\n  if (ASC_LOW_MEMORY_LIMIT) {\r\n    unreachable();\r\n    return;\r\n  }\r\n  // Here, both rounding performed in searchBlock ...\r\n  const halfMaxSize = BLOCK_MAXSIZE >> 1;\r\n  if (size < halfMaxSize) { // don't round last fl\r\n    const invRound = (sizeof<usize>() * 8 - 1) - SL_BITS;\r\n    size += (1 << (invRound - clz<usize>(size))) - 1;\r\n  }\r\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\r\n  // to merge with the tail block, that's one time, otherwise it's two times.\r\n  var pagesBefore = memory.size();\r\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\r\n  var pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\r\n  var pagesWanted = max(pagesBefore, pagesNeeded); // double memory\r\n  if (memory.grow(pagesWanted) < 0) {\r\n    if (memory.grow(pagesNeeded) < 0) unreachable();\r\n  }\r\n  var pagesAfter = memory.size();\r\n  addMemory(root, <usize>pagesBefore << 16, <usize>pagesAfter << 16);\r\n}\r\n\r\n/** Prepares and checks an allocation size. */\r\nfunction prepareSize(size: usize): usize {\r\n  if (size >= BLOCK_MAXSIZE) throw new Error(\"allocation too large\");\r\n  return max<usize>((size + AL_MASK) & ~AL_MASK, BLOCK_MINSIZE); // align and ensure min size\r\n}\r\n\r\n/** Initilizes the root structure. */\r\nexport function maybeInitialize(): Root {\r\n  var root = ROOT;\r\n  if (!root) {\r\n    let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\r\n    let pagesBefore = memory.size();\r\n    let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\r\n    if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\r\n    root = changetype<Root>(rootOffset);\r\n    root.flMap = 0;\r\n    SETTAIL(root, changetype<Block>(0));\r\n    for (let fl: usize = 0; fl < FL_BITS; ++fl) {\r\n      SETSL(root, fl, 0);\r\n      for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\r\n        SETHEAD(root, fl, sl, null);\r\n      }\r\n    }\r\n    let memStart = (rootOffset + ROOT_SIZE + AL_MASK) & ~AL_MASK;\r\n    if (ASC_LOW_MEMORY_LIMIT) {\r\n      const memEnd = <usize>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\r\n      if (memStart <= memEnd) addMemory(root, memStart, memEnd);\r\n      else unreachable(); // low memory limit already exceeded\r\n    } else {\r\n      addMemory(root, memStart, memory.size() << 16);\r\n    }\r\n    ROOT = root;\r\n  }\r\n  return root;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@lazy\r\nvar collectLock: bool = false;\r\n\r\n/** Allocates a block of the specified size. */\r\nexport function allocateBlock(root: Root, size: usize, id: u32): Block {\r\n  if (DEBUG) assert(!collectLock); // must not allocate while collecting\r\n  var payloadSize = prepareSize(size);\r\n  var block = searchBlock(root, payloadSize);\r\n  if (!block) {\r\n    if (gc.auto) {\r\n      if (DEBUG) collectLock = true;\r\n      __collect();\r\n      if (DEBUG) collectLock = false;\r\n      block = searchBlock(root, payloadSize);\r\n      if (!block) {\r\n        growMemory(root, payloadSize);\r\n        block = changetype<Block>(searchBlock(root, payloadSize));\r\n        if (DEBUG) assert(block); // must be found now\r\n      }\r\n    } else {\r\n      growMemory(root, payloadSize);\r\n      block = changetype<Block>(searchBlock(root, payloadSize));\r\n      if (DEBUG) assert(block); // must be found now\r\n    }\r\n  }\r\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\r\n  block.gcInfo = 0; // RC=0\r\n  block.rtId = id;\r\n  block.rtSize = <u32>size;\r\n  removeBlock(root, <Block>block);\r\n  prepareBlock(root, <Block>block, payloadSize);\r\n  if (isDefined(ASC_RTRACE)) onalloc(<Block>block);\r\n  return <Block>block;\r\n}\r\n\r\n/** Reallocates a block to the specified size. */\r\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\r\n  var payloadSize = prepareSize(size);\r\n  var blockInfo = block.mmInfo;\r\n\r\n  // possibly split and update runtime size if it still fits\r\n  if (payloadSize <= (blockInfo & ~TAGS_MASK)) {\r\n    prepareBlock(root, block, payloadSize);\r\n    block.rtSize = <u32>size;\r\n    return block;\r\n  }\r\n\r\n  // merge with right free block if merger is large enough\r\n  var right = GETRIGHT(block);\r\n  var rightInfo = right.mmInfo;\r\n  if (rightInfo & FREE) {\r\n    let mergeSize = (blockInfo & ~TAGS_MASK) + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\r\n    if (mergeSize >= payloadSize) {\r\n      removeBlock(root, right);\r\n      // TODO: this can yield an intermediate block larger than BLOCK_MAXSIZE, which\r\n      // is immediately split though. does this trigger any assertions / issues?\r\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\r\n      block.rtSize = <u32>size;\r\n      prepareBlock(root, block, payloadSize);\r\n      return block;\r\n    }\r\n  }\r\n\r\n  // otherwise move the block\r\n  var newBlock = allocateBlock(root, size, block.rtId); // may invalidate cached blockInfo\r\n  newBlock.gcInfo = block.gcInfo; // keep RC\r\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, size);\r\n  if (changetype<usize>(block) >= __heap_base) {\r\n    if (isDefined(ASC_RTRACE)) onrealloc(block, newBlock);\r\n    freeBlock(root, block);\r\n  }\r\n  return newBlock;\r\n}\r\n\r\n/** Frees a block. */\r\nexport function freeBlock(root: Root, block: Block): void {\r\n  var blockInfo = block.mmInfo;\r\n  block.mmInfo = blockInfo | FREE;\r\n  insertBlock(root, block);\r\n  if (isDefined(ASC_RTRACE)) onfree(block);\r\n}\r\n\r\n/** Checks that a used block is valid to be freed or reallocated. */\r\nfunction checkUsedBlock(ref: usize): Block {\r\n  var block = changetype<Block>(ref - BLOCK_OVERHEAD);\r\n  assert(\r\n    ref != 0 && !(ref & AL_MASK) &&  // must exist and be aligned\r\n    !(block.mmInfo & FREE) &&        // must be used\r\n    !(block.gcInfo & ~REFCOUNT_MASK) // not buffered or != BLACK\r\n  );\r\n  return block;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __alloc(size: usize, id: u32): usize {\r\n  return changetype<usize>(\r\n    allocateBlock(maybeInitialize(), size, id)\r\n  ) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __realloc(ref: usize, size: usize): usize {\r\n  return changetype<usize>(\r\n    reallocateBlock(maybeInitialize(), checkUsedBlock(ref), size)\r\n  ) + BLOCK_OVERHEAD;\r\n}\r\n\r\n// @ts-ignore: decorator\r\n@global @unsafe\r\nexport function __free(ref: usize): void {\r\n  freeBlock(maybeInitialize(), checkUsedBlock(ref));\r\n}\r\n","/// <reference path=\"./rt/index.d.ts\" />\r\n\r\n/** Garbage collector interface. */\r\nexport namespace gc {\r\n\r\n  /** Can be set to `false` to disable automatic collection. Defaults to `true`. */\r\n  export var auto: bool = true;\r\n\r\n  /** Performs a full garbage collection cycle. */\r\n  export function collect(): void {\r\n    __collect();\r\n  }\r\n}\r\n","// The entry file of your WebAssembly module.\r\nconst BYTE_PER_IMAGE = 4;\r\n\r\nexport function InvertColors(width: i32, height: i32):void {\r\n let offset = width * height * BYTE_PER_IMAGE;\r\n\r\n for(let i = 1; i < offset+1; i++){\r\n     let currByte = load<u8>(i-1);\r\n     if(i % 4 !== 0){\r\n         currByte = 255 - currByte;\r\n     }\r\n     store<u8>(offset + i - 1, currByte);\r\n }\r\n}\r\n\r\n\r\nexport function Sepia(width: i32, height: i32): void {\r\n    let offset = width * height * BYTE_PER_IMAGE;\r\n    for(let i = 0; i < offset; i+=4){\r\n        let red =  load<u8>(i);\r\n        let green = load<u8>(i + 1);\r\n        let blue = load<u8>(i + 2);\r\n        let alpha = load<u8>(i + 3);\r\n        let luma = red * 0.2126 + green * 0.7152 + blue * 0.0722;\r\n        store<u8>(offset + i, <u8>luma);\r\n        store<u8>(offset + i+1, <u8>luma);\r\n        store<u8>(offset + i+2, <u8>luma);\r\n        store<u8>(offset + i+3, alpha);\r\n    }\r\n}\r\n\r\nexport function Visible(width: i32, height: i32, value: u8): void {\r\n    let offset = width * height * BYTE_PER_IMAGE;\r\n    for(let i = 0; i < offset; i+=4){\r\n        let alpha = load<u8>(i + 3);\r\n        alpha -=  value;\r\n\r\n        store<u8>(offset + i+3, alpha);\r\n    }\r\n}\r\n\r\nexport function Rotate(width: i32, height: i32, rotate: i32): void {\r\n    let offset = width * height * BYTE_PER_IMAGE;\r\n    let i = 0;\r\n\r\n    let d1Start = 0;\r\n    let d1Limit = width;\r\n    let d1Advance = 1;\r\n    let d1Multiplier = 1;\r\n    let d2Start = 0;\r\n    let d2Limit = height;\r\n    let d2Advance = 1;\r\n    let d2Multiplier = width;\r\n\r\n    if(rotate == 90){\r\n        d1Start = height-1;\r\n        d1Limit = height;\r\n        d1Advance = -1;\r\n        d1Multiplier = width;\r\n        d2Start = 0;\r\n        d2Limit = width;\r\n        d2Advance = 1;\r\n        d2Multiplier = 1;\r\n    }else if(rotate === 180){\r\n        d1Start = width -1;\r\n        d1Limit = width;\r\n        d1Advance = -1;\r\n        d1Multiplier = 1;\r\n        d2Start = height - 1;\r\n        d2Limit = height;\r\n        d2Advance = -1;\r\n        d2Multiplier = width;\r\n    }else if(rotate === 270){\r\n        d1Start = 0;\r\n        d1Limit = height;\r\n        d1Advance = 1;\r\n        d1Multiplier = width;\r\n        d2Start = width - 1;\r\n        d2Limit = width;\r\n        d2Advance = -1;\r\n        d2Multiplier = 1;\r\n    }\r\n\r\n    for(let d2 = d2Start; d2 >= 0 && d2 < d2Limit; d2 += d2Advance){\r\n        for(let d1 = d1Start; d1 >= 0 && d1 < d1Limit; d1+=d1Advance) {\r\n            let in_idx = ((d1 * d1Multiplier) + (d2 * d2Multiplier));\r\n            store<u32>(offset + i * BYTE_PER_IMAGE, load<u32>(in_idx * BYTE_PER_IMAGE));\r\n            i += 1;\r\n        }\r\n    }\r\n}\r\n\r\n// export function Rotate(width: i32, height: i32, rotate: i32): void {\r\n//     for(let y = 0; y < height; y++){\r\n//         for(let x = 0; x < width; x++){\r\n//             let inPixel = load<u32>(y * width + x);\r\n//             store<u32>(rorate(x,y),inPixel);\r\n//         }\r\n//     }\r\n// }\r\n"]}